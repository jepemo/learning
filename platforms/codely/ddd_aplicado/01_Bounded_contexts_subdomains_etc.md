# Bounded Contexts, subdomains y modules: Creando nuestra aplicaci√≥n

## C√≥mo definir Bounded Contexts

* Los Bounded Context son agrupaciones flexibles que pueden cambiar a lo largo del tiempo
* Lenguaje ubicuo: palabras de negocio que se utilizan para definir conceptos en el codigo
  * Por ejemplo en Codely: La Home, el Backoffice, el Mooc, el Blog‚Ä¶
* Ejemplo de separacion logica, primer pensamiento: Frontend y Backend
* Ejemplo: La separaci√≥n l√≥gica que establecer√≠amos ser√≠a a nivel de bounded contexts:
    * Mooc
    * Backoffice del Mooc
    * Blog
 * Adem√°s dentro de los BoundedContext hay modulos (mini-bounded-context):
   * Son elementos que tienen sentido dentro de un bounded context.
   * Ejemplo: 
     * En Mooc serian: Videos, Courses, Estudiantes, etc.
     * En Backoffice serian: Courses, tickets, estudiantes, etc.
  * Aplicaciones (c√≥mo y donde queremos desplegar):
    * Web, dispositivos m√≥viles, etc
    * Si tenemos nuestras aplicaciones en el mismo repo que los bounded contexts, nuestras aplicaciones web podr√°n comunicarse con estos bounded contexts sin necesidad de salir al exterior del servidor (No har√° falta establecer comunicaciones HTTP, TCP, ‚Ä¶) mejorando enormemente la latencia en nuestra aplicaci√≥n
    * Ejemplos de aplicaciones:
      * MoocFrontend (Cliente WEB), MoocBackend (API), BackofficeFront., BackOfficeBack., etc.
      
### Alternativas

* Existirian otras formas de organizar el codigo.
* Ejemplo 1: Apps dentro de los Bounded Contexts
  * Ventajas: Codigo Autocontenido y mas recogido
  * Inconvenientes: Puede ser engorroso si nuestra aplicaci√≥n tiene que llamar no solo a la api de su bounded context sino a otras externas
* Ejemplo 2: Modulos dentro de las Apps (frontend y backend que contendr√≠an a los m√≥dulos.):  
  * Ventajas: El c√≥digo est√° agrupado a nivel de conceptos
  * Inconvenientes: Estar√≠amos confundiendo los m√≥dulos propiamente dichos con una agrupaci√≥n de c√≥digo por conceptos
  
* Esto al final es un proceso iterativo, en el que se quiere
  * Aislarse para no chocar entre varios equipos/desarrolladores que trabajan cada uno en su BC
  * Tener la comunicacion en una direccion, sin tener que salir fuera para tener que llamar a otro sitio.
  
* Ejemplo codigo: https://github.com/CodelyTV/php-ddd-example

## Diferencias entre Bounded Contexts, Subdomains, Modules, y Shared Kernel

* **Context Map**: "Mappea" los conceptos del dominio a los "Boounded Context"
* **Subdomain**: Hace referencia ex√°ctamente a lo mismo que los Bounded Contexts. Mientras que Subdomain estar√≠a en el terreno de la problem√°tica que queremos resolver, Bounded Context estar√≠a en el terreno de la soluci√≥n que damos a dicho problema.
* **MicroServicio**: Es una pr√°ctica habitual desplegar aplicaciones como Microservicios. Aunque normalmente suele ir en relaci√≥n 1 a 1 con los Bounded Contexts, tambi√©n es posible que se relacionen 2 microservicios(Por ejemplo la parte backend y frontend) con un mismo "contexto".
* **Shared Kernel**: Se trata de c√≥digo compartido entre Bounded Contexts y entre M√≥dulos dentro de un mismo Bounded Context (Tambi√©n podemos encontrarlo bajo el nombre de Common o Shared). Aqu√≠ dejaremos las cosas con la menor l√≥gica posible para no generar acoplamiento en los contextos.
  * Tip: Si nos llev√°semos un Bounded Context en otro proyecto distinto, tendr√≠amos que llevarnos tanto ese Bounded Context como la carpeta de Shared Kernel


|                                        | Framework coupled code | Modules | Bounded Contexts       | Microservices          |
|----------------------------------------|------------------------|---------|------------------------|------------------------|
| **Learning Curve**                     | Low                    | Medium  | High                   | High++                 |
| **Teams autonomy**                     | Low                    | Medium+ | High                   | High++                 |
| **Infrastructure**                     | Shared & Coupled       | shared  | Isolated & distributed | Isolated & distributed |
| **Code maintainability/extensibility** | Low--                  | High    | High+                  | High++                 |
| **Infrastructure complexity**          | Low                    | Medium  | High                   | High++++               |
| **Comunication Between**               | Coupled                | Buses   | Buses                  | Distributed Buses      |
| **Deploy**                             | Shared                 | Shared  | Shared                 | Isolated               |


* **Learning Curve**: La curva de aprendizaje se incrementa considerablemente cuando nos enfrentamos a un sistema distribu√≠do entre distintos microservicios frente a aquel c√≥digo acoplado al framework en el que todo est√° junto. Por eso, lo ideal es avanzar progresivamente, iterando en los distintos estadios hasta llegar a una estructura de microservicios.
* **Autonom√≠a de los equipos**: Trabajar con Bounded Contexts y Microservicios nos va a permitir separar los equipos de modo que puedan desarrollar y desplegar de manera independiente. Al otro lado, trabajar con un c√≥digo acoplado nos obliga a que los equipos coincidan en el mismo c√≥digo tanto al desarrollarlo como en los despliegues.
* **Infraestructura**: En un c√≥digo acoplado al framework, puesto que todo est√° unido, podemos toparnos con un efecto domin√≥ üÄÑ de modo que si una de las piezas implicadas falla, todo lo dem√°s falle. En el otro extremo, al estar aislada la infraestructura, si una de ellas falla (Por ejemplo la referente a Usuarios) el resto seguir√≠a funcionando con normalidad.
* **Mantenibilidad/Extensibilidad del c√≥digo**: Por supuesto, cuanto m√°s desacoplado y aislado est√© nuestro c√≥digo, m√°s f√°cil ser√° mantenerlo y extenderlo. Como hemos comentado en otras ocasiones, tener nuestro c√≥digo fuertemente acoplado nos obligar√° a que cada modificaci√≥n que hagamos lleve a tocar en m√∫ltiples sitios.
* **Complejidad de la Infraestuctura**: Tener menos elementos implicados, como en el caso del c√≥digo acoplado, supone una menor complejidad en t√©rminos de infraestructura. Por eso al trabajar con Bounded Contexts y especialmente con Microservicios, estaremos aumentando bastante su complejidad (No ser√° lo mismo tener un s√≥lo deploy y una s√≥la BD que tener m√∫ltiples deploys y trabajar con varias BBDD).
* **Comunicaci√≥n entre ellos**: En el caso del c√≥digo acoplado, la comunicaci√≥n ser√° inevitablemente acoplada (Por ejemplo a trav√©s de Inyecci√≥n de Dependencias). Por otro lado, la comunicaci√≥n puede ser a trav√©s de Buses en el caso de M√≥dulos y Bounded Contexts, o por medio de Buses distribuidos entre Microservicios
* **Despliegue**: Respecto a nivel de Despliegue, el cambio se observa en el paso a Microservicios, donde ser√° aislado para cada uno de ellos, lo cual nos permitir√° una mayor escalabilidad (Se despliega una parte concreta de nuestra aplicaci√≥n)

## Estructura de carpetas en un monorepositorio

* Usan un monorepo, es decir todas las aplicaciones y "bounded context" en el mismo arbol.
* Backend no es solo la API. Es API mas consumidores, etc.
* La estructura general:
  * applications: tanto backend como frontend. Todos los puntos de entrada de nuestra aplicaci√≥n
    * backoffice_backend
    * backoffice_frontend
    * mooc_backend
    * mooc_frontend
  * src (bounded contexts : recoger los distintos contextos de nuestra aplicaci√≥n y sus correspondiente m√≥dulos)
    * Backoffice
      * Videos
      * ...
      * Shared
    * Mooc
      * Videos
      * Courses
      * Shared (DI BC/BBDD)
      * ...
      * Roadmap
    * Shared (userId, codigo infraestructura compartida: BDConnection, etc.)
      * Domain
      * Infraestructure
  * test
    * applications
      * backoffice_backend
      * backoffice_frontend
      * mooc_backend
      * mooc_frontend
    * src
      * Backoffice
      * Mooc
        * Videos
        * Courses
        * Shared
        * ...
        * Roadmap
      * Shared
    
    
